# 6.1 Descrição do Código

## Introdução

Este documento descreve em detalhes a organização do código do sistema Digi Eventos, explicando a estrutura de arquivos, componentes criados, padrões de desenvolvimento e convenções adotadas pela equipe.

## Organização Geral do Projeto

### Estrutura do Monorepo

O projeto é organizado como um monorepo, uma estratégia que consolida múltiplas aplicações relacionadas em um único repositório Git. Esta abordagem traz diversos benefícios:

**Compartilhamento de Código**: Pacotes comuns (como o schema do banco de dados) são compartilhados entre frontend e backend sem necessidade de publicação em registros externos.

**Sincronização de Versões**: Todas as dependências são gerenciadas centralmente, evitando conflitos de versão entre diferentes partes do sistema.

**Desenvolvimento Integrado**: Mudanças que afetam múltiplas aplicações podem ser feitas em um único commit, facilitando o rastreamento e revisão.

**Build Otimizado**: O Turborepo gerencia cache de builds, executando apenas o necessário quando algo muda.

### Divisão de Responsabilidades

**apps/web** - Aplicação Frontend:
- Interface do usuário construída com React
- Páginas e componentes visuais
- Gerenciamento de estado do cliente
- Comunicação com a API backend

**apps/server** - API Backend:
- Endpoints REST para operações de negócio
- Autenticação e autorização de usuários
- Validação de dados de entrada
- Lógica de negócio e regras do sistema
- Integração com serviços externos (S3)

**packages/db** - Camada de Dados:
- Definição do schema do banco de dados
- Tipos TypeScript gerados automaticamente
- Scripts de migração e seed
- Configuração do Drizzle ORM

## Arquitetura do Backend (apps/server)

### Padrão de Arquitetura em Camadas

O backend segue uma arquitetura em três camadas bem definidas:

**Camada de Apresentação (Routes)**: Responsável por receber requisições HTTP, validar parâmetros e retornar respostas. Esta camada não contém lógica de negócio, apenas orquestra chamadas para a camada de serviço.

**Camada de Serviço (Service)**: Contém toda a lógica de negócio da aplicação. É aqui que ficam as regras, validações complexas, cálculos e orquestrações de operações. Esta camada é independente do protocolo HTTP, facilitando testes e reuso.

**Camada de Dados (Database)**: Gerencia todo acesso ao banco de dados através do Drizzle ORM. Responsável por queries, inserções, atualizações e deleções.

### Organização em Módulos

Cada funcionalidade do sistema é organizada como um módulo independente. Um módulo típico contém três arquivos:

**index.ts** - Define as rotas HTTP do módulo. Exemplo: `/events`, `/events/:id`, etc. Cada rota valida entrada, chama o serviço apropriado e formata a resposta.

**service.ts** - Implementa a lógica de negócio. Contém funções que realizam operações como criar evento, validar capacidade máxima, verificar permissões, etc.

**model.ts** - Define tipos e schemas de validação usando o sistema de tipos do Elysia. Garante que dados recebidos estão no formato correto.

### Módulos Implementados

**Auth Module** - Gerencia autenticação e autorização:
- Login com email e senha
- Criação de novos usuários (signup)
- Geração de tokens JWT
- Validação de credenciais
- Hash seguro de senhas usando Bun

**Events Module** - Gerenciamento completo de eventos:
- Listagem de eventos com filtros (categoria, data, status)
- Criação de novos eventos (apenas administradores)
- Atualização de eventos existentes
- Cancelamento de eventos
- Upload de imagens de capa para S3
- Controle de capacidade máxima

**Users Module** - Gerenciamento de usuários:
- Listagem de usuários (apenas admin)
- Visualização de perfil próprio
- Atualização de dados pessoais
- Upload de avatar
- Alteração de senha (com verificação da senha atual)
- Redefinição de senha por administrador

**Registrations Module** - Inscrições em eventos:
- Inscrição de usuários em eventos
- Cancelamento de inscrições
- Verificação de vagas disponíveis
- Listagem de eventos que o usuário está inscrito
- Validação de evento não cancelado

**Categories Module** - Categorias de eventos:
- CRUD completo de categorias
- Validação de nome único
- Apenas administradores podem gerenciar

### Middleware de Autenticação

O sistema implementa um middleware de autenticação que:
- Extrai o token JWT do header `Authorization`
- Valida a assinatura do token usando o secret configurado
- Busca o usuário correspondente no banco de dados
- Injeta o objeto `user` no contexto da requisição
- Lança erro apropriado se token inválido ou ausente

Este middleware é aplicado seletivamente em rotas que requerem autenticação, permitindo que rotas públicas (como login e listagem de eventos) sejam acessadas sem token.

### Tratamento de Erros

O sistema utiliza uma classe customizada `AppError` que padroniza erros:
- Cada erro tem um código (NOT_FOUND, UNAUTHORIZED, FORBIDDEN, etc.)
- Mensagens claras em português
- Status HTTP apropriado para cada tipo de erro
- Stack trace para debugging em desenvolvimento

## Arquitetura do Frontend (apps/web)

### Roteamento Baseado em Arquivos

O frontend utiliza TanStack Router com roteamento baseado em arquivos, onde a estrutura de pastas determina as URLs:

```
routes/
├── __root.tsx          → Layout principal
├── index.tsx           → Homepage (/)
├── auth/
│   └── sign-in.tsx     → Login (/auth/sign-in)
└── app/
    ├── route.tsx       → Layout autenticado (/app)
    ├── dashboard.tsx   → Dashboard (/app/dashboard)
    └── evento/
        └── ...         → Páginas de eventos
```

Esta abordagem traz vantagens:
- URLs refletem diretamente a estrutura de código
- Type safety nas navegações entre páginas
- Lazy loading automático de rotas
- Layouts compartilhados entre páginas filhas

### Componentes de UI

O projeto utiliza um sistema de componentes baseado em shadcn/ui (coss/ui), que fornece componentes acessíveis e customizáveis:

**Componentes Primitivos** (ui/):
- `Button`: Botões com variantes (primary, outline, ghost, destructive)
- `Input`: Campos de texto com validação
- `Card`: Containers de conteúdo estruturado
- `Dialog`: Modais para confirmações e formulários
- `Table`: Tabelas responsivas com sorting
- `Toast`: Notificações temporárias
- `Avatar`: Exibição de foto de perfil

**Componentes Compostos**:
- `Header`: Navegação principal com autenticação
- `PageHeader`: Cabeçalho padrão de páginas internas
- `ImageUploadField`: Upload de imagens com preview
- `FileUpload`: Upload genérico de arquivos

### Gerenciamento de Estado

**Estado Local**: Componentes usam `useState` e `useReducer` para estado UI (modais abertos, formulários, etc.)

**Estado do Servidor**: TanStack Query gerencia todo estado que vem da API:
- Cache automático de dados
- Revalidação em background
- Otimistic updates
- Retry automático em falhas
- Invalidação inteligente

**Estado Global**: Context API para dados compartilhados:
- `AuthContext`: Usuário logado e funções de autenticação
- `ThemeProvider`: Tema atual (light/dark/system)

### Geração Automática de Tipos

O frontend usa Kubb para gerar automaticamente código TypeScript a partir da especificação OpenAPI do backend:

**Tipos**: Interfaces para todos os DTOs (requests e responses)

**Hooks**: Hooks do TanStack Query para cada endpoint da API, com tipos já inferidos

**Clients**: Funções de requisição HTTP tipadas

Isso garante que qualquer mudança na API seja refletida automaticamente no frontend, evitando inconsistências.

## Camada de Banco de Dados (packages/db)

### Schema do Banco

O schema é definido usando Drizzle ORM, que oferece um DSL type-safe para definir tabelas:

**Tabela Users**:
- ID único (UUID v7)
- Email único e obrigatório
- Nome completo
- Senha (hash bcrypt)
- URL do avatar (opcional)
- Role (admin ou user)
- Timestamps de criação

**Tabela Events**:
- ID único
- Título e descrição
- Localização e horários (início e fim)
- Capacidade máxima
- URL da imagem de capa
- Referência ao criador (user)
- Timestamp de cancelamento (soft delete)
- Relação com categoria

**Tabela Registrations**:
- Relacionamento many-to-many entre users e events
- Controla quem está inscrito em quais eventos
- Previne inscrições duplicadas via constraint única

**Tabela Categories**:
- Nome único da categoria
- Usado para filtrar eventos

### Migrations e Seed

**Migrations**: O Drizzle gera automaticamente SQL para criar/alterar tabelas baseado no schema TypeScript. Mudanças no schema são rastreadas e aplicadas incrementalmente.

**Seed**: Script que popula o banco com dados iniciais:
- Usuário administrador padrão
- Usuários de exemplo
- Categorias comuns
- Eventos de demonstração
- Útil para desenvolvimento e testes

## Convenções de Código

### Nomenclatura de Arquivos

O projeto segue convenções consistentes para facilitar navegação:

**Frontend**:
- Componentes React: `PascalCase.tsx` (ex: `UserProfile.tsx`)
- Hooks personalizados: `use-kebab-case.ts` (ex: `use-auth.ts`)
- Utilitários: `kebab-case.ts` (ex: `query-client.ts`)

**Backend**:
- Todos arquivos: `kebab-case.ts` (ex: `s3-upload.ts`)
- Módulos organizados em pastas com estrutura padrão

### Nomenclatura de Código

**Variáveis e Funções**: `camelCase`
```typescript
const userName = 'João'
function calculateTotal() { }
```

**Constantes**: `UPPER_SNAKE_CASE`
```typescript
const MAX_FILE_SIZE = 5 * 1024 * 1024
const API_BASE_URL = 'http://localhost:3000'
```

**Tipos e Classes**: `PascalCase`
```typescript
interface UserProfile { }
class EventService { }
```

### Comentários no Código

O projeto adota uma filosofia de "código auto-explicativo", onde:

**Nomes descritivos reduzem necessidade de comentários**: Preferimos `calculateDiscountedPrice()` ao invés de `calc()` com comentário explicando.

**Comentários explicam "porquê", não "o quê"**: Ao invés de comentar "loop pelos eventos", comentamos "eventos devem ser processados em ordem cronológica para garantir consistência".

**JSDoc para APIs públicas**: Funções expostas a outros módulos têm documentação completa com parâmetros, retorno e exemplos.

**TODOs rastreáveis**: Incluem autor e descrição clara do que falta fazer.

### Validação de Dados

Toda entrada de dados é validada em duas camadas:

**Validação de Schema**: Elysia valida automaticamente tipos, formatos, tamanhos mínimos/máximos baseado no schema definido.

**Validação de Negócio**: Service layer valida regras específicas (ex: evento não pode ter data no passado, capacidade não pode ser negativa).

### Tratamento de Async/Await

Todo código assíncrono usa async/await ao invés de Promises diretas, tornando o código mais legível e linear. Erros são tratados com try/catch apropriados.

## Diagramas de Implementação

### Diagrama de Componentes

O sistema pode ser visualizado através de um diagrama de componentes UML que mostra:

**Camada de Apresentação (Frontend)**:
- Componente React App contendo páginas e componentes UI
- TanStack Query gerenciando cache e estado servidor
- Router controlando navegação

**Camada de API (Backend)**:
- Módulos independentes (Auth, Events, Users, etc.)
- Middlewares compartilhados (Auth, CORS, Error Handler)
- Serviços utilitários (S3 Upload, JWT)

**Camada de Dados**:
- Drizzle ORM abstraindo acesso ao PostgreSQL
- Schemas tipados gerando tipos TypeScript
- Queries type-safe

**Serviços Externos**:
- AWS S3 para armazenamento de imagens
- PostgreSQL para persistência

As setas indicam dependências e fluxo de dados entre componentes.

### Diagrama de Pacotes

Mostra a organização do monorepo:

**Pacote apps/web**:
- Depende de `packages/db` para tipos
- Gera tipos da API via OpenAPI

**Pacote apps/server**:
- Depende fortemente de `packages/db` para schema e queries
- Expõe API REST para `apps/web`

**Pacote packages/db**:
- Independente, não depende de outros pacotes
- Exporta schema, tipos e conexão com banco

### Diagrama de Sequência - Autenticação
- Imagem

### Diagrama de Fluxo - Criação de Evento
- Imagem

## Padrões de Projeto Utilizados

### Repository Pattern

Embora não explícito, o Drizzle ORM atua como um Repository, abstraindo detalhes de acesso a dados e permitindo queries type-safe.

### Service Layer Pattern

Toda lógica de negócio fica encapsulada em services, separada de controllers (rotas) e repositories (database).

### Dependency Injection

Elysia permite injeção de dependências através de plugins, facilitando testes e modularização.

### Factory Pattern

Funções como `uploadToS3` e `createJWT` atuam como factories, encapsulando complexidade de criação de objetos.

### Middleware Pattern

Chain of responsibility implementado via middlewares do Elysia para autenticação, logging, error handling.

## Segurança

### Autenticação JWT

Tokens assinados criptograficamente com secret de 256 bits. Tokens não podem ser forjados sem acesso ao secret.

### Hash de Senhas

Senhas nunca armazenadas em texto plano. Usamos Bun.password.hash que implementa bcrypt com salt automático.

### Validação de Entrada

Todo input é validado e sanitizado antes de processamento. Proteção contra SQL injection via prepared statements do ORM.

### CORS Configurado

Apenas origens específicas podem acessar a API. Em produção, deve ser configurado com domínio real.